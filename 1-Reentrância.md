# üîÑ **Construindo Web3 Segura: O Ataque de Reentr√¢ncia em Smart Contracts**

> *"Reentr√¢ncia √© o pesadelo do dev: empresta o dinheiro e, antes de anotar, o ‚Äòamigo‚Äô pede de novo‚Ä¶ e de novo!"*  
> ‚Äî *Inspirado por Hacken: "Hackers evoluem, mas devs preparados vencem!"* üõ°Ô∏è

Em **2025**, smart contracts s√£o o cora√ß√£o da **Web3**, gerenciando **mais de US$ 200 bilh√µes em TVL** em DeFi, NFTs e dApps, rodando em blockchains como **Ethereum** e **BNB Chain**. S√£o **cofres de vidro**: transparentes, imut√°veis, mas fr√°geis se mal projetados. **Reentr√¢ncia (A04)** no **OWASP Smart Contract Top 10 2025** ocorre quando um contrato faz chamadas externas antes de atualizar o estado, permitindo que atacantes re-entrem na fun√ß√£o e drenem fundos. Em **2024**, causou **~US$ 35 milh√µes em perdas**. Este artigo explora reentr√¢ncia com uma abordagem **did√°tica e t√©cnica**, analisando o **The DAO Hack (2016)**, um marco que mudou a Ethereum, com pr√°ticas para proteger a Web3. Vamos fechar esse cofre? üí™

---

## üö® **O que √© Reentr√¢ncia?**

Pense num caixa eletr√¥nico que entrega R$ 100 **antes** de descontar seu saldo. Se voc√™ sacar novamente nesse intervalo, ele paga de novo, porque o saldo n√£o foi atualizado. **Reentr√¢ncia** acontece quando um smart contract faz uma **chamada externa** (ex.: envia ETH) antes de atualizar vari√°veis cr√≠ticas (ex.: `saldos[msg.sender] = 0`). Um contrato malicioso intercepta a chamada via `receive`/`fallback` e re-entra na fun√ß√£o, repetindo a a√ß√£o at√© drenar os fundos.

> üòÑ *Piada*: "Reentr√¢ncia? √â como um banco que te d√° o dinheiro e esquece de debitar!"

**Como funciona na pr√°tica?**  
- Contrato envia ETH/tokens antes de zerar o saldo.  
- Atacante re-entra via `receive`/`fallback`, chamando a mesma fun√ß√£o.  
- O saldo, ainda n√£o atualizado, permite m√∫ltiplos saques.  

**Estat√≠sticas de Impacto**: Reentr√¢ncia (A04) causou **US$ 35M em perdas em 2024**, com contratos legados e fluxos complexos como alvos. O **The DAO Hack (2016)** drenou **US$ 50M**, moldando pr√°ticas modernas.

---

## üõ† **Contexto T√©cnico: Como Funciona a Reentr√¢ncia**

### **Mec√¢nica do Ataque**

1. **Chamada Externa Prematura**:  
   - **Erro**: Enviar ETH/tokens (ex.: via `call`) antes de atualizar o estado.  
   - **Explora√ß√£o**: Atacante re-entra na fun√ß√£o via `receive`/`fallback`.  
   - **Exemplo**: Saque que paga antes de zerar `saldos`.

2. **Ciclo de Reentr√¢ncia**:  
   - **Erro**: Falta de guarda (ex.: `ReentrancyGuard`) ou padr√£o CEI (Checks-Effects-Interactions).  
   - **Explora√ß√£o**: Atacante repete chamadas at√© esgotar fundos ou gas.  

3. **Depend√™ncia de Contratos Externos**:  
   - **Erro**: Interagir com contratos n√£o confi√°veis.  
   - **Explora√ß√£o**: Contrato malicioso explora a janela de reentr√¢ncia.

**Passos de um Ataque T√≠pico**:  
1. **An√°lise**: Atacante examina c√≥digo p√∫blico por chamadas externas antes de atualiza√ß√µes.  
2. **Explora√ß√£o**: Implanta contrato que re-entra na fun√ß√£o vulner√°vel.  
3. **Impacto**: Drena fundos ou corrompe o contrato.

### **Exemplo de C√≥digo Solidity Vulner√°vel**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract BancoVulneravel {
    mapping(address => uint256) public saldos;

    function depositar() external payable {
        saldos[msg.sender] += msg.value;
    }

    function sacar() external {
        uint256 valor = saldos[msg.sender];
        require(valor > 0, "Sem saldo");
        // Vulner√°vel: Chamada externa antes de atualizar estado
        (bool ok, ) = msg.sender.call{value: valor}("");
        require(ok, "Falha no envio");
        saldos[msg.sender] = 0; // Tarde demais
    }
}
```

**Contrato Atacante**:
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Atacante {
    BancoVulneravel public banco;

    constructor(address _banco) {
        banco = BancoVulneravel(_banco);
    }

    function atacar() external payable {
        require(msg.value >= 1 ether, "Precisa de 1 ETH");
        banco.depositar{value: 1 ether}();
        banco.sacar();
    }

    receive() external payable {
        if (address(banco).balance >= 1 ether) {
            banco.sacar(); // Re-entra antes de zerar saldo
        }
    }
}
```

**Como o ataque funciona?**  
- Atacante deposita 1 ETH e chama `sacar`.  
- `sacar` envia 1 ETH, acionando `receive` do atacante.  
- `receive` chama `sacar` novamente, antes de `saldos[msg.sender] = 0`.  
- Repete at√© drenar o contrato.

**Contrato Seguro**:
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract BancoSeguro is ReentrancyGuard {
    mapping(address => uint256) public saldos;

    function depositar() external payable {
        saldos[msg.sender] += msg.value;
    }

    function sacar() external nonReentrant {
        uint256 valor = saldos[msg.sender];
        require(valor > 0, "Sem saldo");
        saldos[msg.sender] = 0; // Efeito primeiro
        (bool ok, ) = msg.sender.call{value: valor}("");
        require(ok, "Falha no envio");
    }
}
```

**Por que √© perigoso?** A transpar√™ncia da blockchain exp√µe chamadas externas, e a aus√™ncia de CEI ou guardas permite drenagem r√°pida. Em 2024, **US$ 35M** foram perdidos para A04.

---

## üìä **Caso Real: The DAO Hack (2016)**

### **Contexto**  
- **The DAO**: Fundo descentralizado na Ethereum para propostas e vota√ß√£o, arrecadando **US$ 150M (~3,6M ETH)**, ou **14% do ETH circulante**.  
- Solidity imaturo, sem padr√µes consolidados.

### **Ataque**  
- **Vulnerabilidade**: Fun√ß√£o `splitDAO` enviava ETH antes de zerar `credit`, permitindo reentr√¢ncia.  
- **Como funcionou?**:  
  - Atacante chamou `splitDAO`, que enviou ETH ao seu contrato.  
  - No `fallback`, re-entrou em `splitDAO`, repetindo antes de `credit = 0`.  
  - Drenou **~3,6M ETH (US$ 50M)**.  

### **Impacto**  
- **Financeiro**: Perda massiva, congelamento de fundos.  
- **Comunit√°rio**: Hard fork criou **Ethereum** (revertida) e **Ethereum Classic** (original).  
- **T√©cnico**: Ado√ß√£o de CEI, `ReentrancyGuard` e auditorias.

### **Li√ß√µes**  
- Atualize estados antes de chamadas externas.  
- Use guardas de reentr√¢ncia.  
- Teste com fuzzing e auditorias.

---


### **A vulnerabilidade**

A fun√ß√£o de ‚Äú*split*‚Äù/retirada **enviava ETH antes de atualizar o saldo** do usu√°rio, abrindo a janela para **reentr√¢ncia**.

**Esbo√ßo vulner√°vel (simplificado):**

```solidity
pragma solidity ^0.4.0;

contract TheDAO {
    mapping(address => uint256) public credit;

    function splitDAO(address receptor) public {
        uint256 valor = credit[msg.sender];
        if (valor > 0) {
            // Interacao externa primeiro -> vulneravel
            if (!receptor.call.value(valor)()) { revert(); }
            credit[msg.sender] = 0; // Efeito apos a interacao
        }
    }
}
```

**Contrato atacante (padr√£o da √©poca, pseudo-legacy):**

```solidity
pragma solidity ^0.4.0;

contract Atacante {
    TheDAO public dao;

    function atacar(address _dao) public {
        dao = TheDAO(_dao);
        dao.splitDAO(this);
    }

    function() public payable {
        if (address(dao).balance >= 1 ether) {
            dao.splitDAO(this); // Re-entra enquanto credit nao foi zerado
        }
    }
}
```

### **Linha do tempo do ataque**

1. **Dep√≥sito**: o atacante participa do DAO e adquire ‚Äúcr√©ditos‚Äù.
2. **Primeira chamada**: aciona a fun√ß√£o de *split*, que **envia ETH** ao atacante.
3. **Reentrada**: no `fallback`, a mesma fun√ß√£o √© chamada **de novo**, **antes** do `credit[msg.sender] = 0`.
4. **Loop**: repete at√© **drenar ~3,6M ETH** (~**US$ 50M** na √©poca).

### **Impacto e repercuss√µes**

* **Financeiro**: drenagem massiva e congelamento tempor√°rio de fundos.
* **Comunit√°rio**: debate sobre **imutabilidade** vs. **justi√ßa** ‚Üí **hard fork** que reverteu o hack na cadeia **Ethereum**; a cadeia **Ethereum Classic (ETC)** manteve o hist√≥rico original.
* **T√©cnico**: consolida√ß√£o de padr√µes (**CEI**, **ReentrancyGuard**), foco em **auditorias** e **testes de seguran√ßa**.



---




## üõ°Ô∏è **Preven√ß√£o Moderna contra Reentr√¢ncia (2025)**

### **Boas Pr√°ticas T√©cnicas**  
- **Checks-Effects-Interactions (CEI)** üîí  
  - Atualize estados antes de chamadas externas.  
  ```solidity
  function sacar() external nonReentrant {
      uint256 valor = saldos[msg.sender];
      require(valor > 0, "Sem saldo");
      saldos[msg.sender] = 0; // Efeito
      (bool ok, ) = msg.sender.call{value: valor}(""); // Intera√ß√£o
      require(ok, "Falha");
  }
  ```  
- **ReentrancyGuard** ‚è≥  
  - Use OpenZeppelin para bloquear reentr√¢ncia.  
  ```solidity
  import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
  contract BancoSeguro is ReentrancyGuard {
      // Fun√ß√µes protegidas com nonReentrant
  }
  ```  
- **Pull-over-Push**: Substitua pagamentos autom√°ticos por retiradas manuais.  
  ```solidity
  function retirar() public nonReentrant {
      uint256 valor = pendenteRetirada[msg.sender];
      pendenteRetirada[msg.sender] = 0;
      (bool ok, ) = msg.sender.call{value: valor}("");
      require(ok, "Falha");
  }
  ```  
- **Minimizar Chamadas Externas**: Evite intera√ß√µes com contratos n√£o confi√°veis.  
- **Auditorias**: Contrate Halborn (92% de detec√ß√£o).

### **Ferramentas de Preven√ß√£o**  
- **Slither/Mythril**: Detectam padr√µes de reentr√¢ncia (92% eficaz).  
- **Echidna/Foundry**: Fuzzing para simular reentr√¢ncia.  
- **Tenderly**: Monitora chamadas suspeitas.  
- **Bounties**: Immunefi pagou **US$ 52K m√©dio** por bugs em 2024.

### **Tend√™ncias em 2025**  
Reentr√¢ncia (A04) causou **US$ 35M em perdas** em 2024, com contratos legados como alvos. CEI e `ReentrancyGuard` reduziram a incid√™ncia, mas fluxos complexos ainda s√£o vulner√°veis.

---

## üéØ **Conclus√£o: Fechando o Cofre de Vidro**

Reentr√¢ncia, como no **The DAO Hack (2016)**, transforma cofres digitais em vidro fr√°gil. Com **US$ 35M perdidos em 2024**, a solu√ß√£o √© clara: **CEI**, **ReentrancyGuard**, **pull-over-push** e auditorias robustas. Ferramentas como Slither, Echidna e Tenderly s√£o as muralhas contra esses ataques. Como disse a Hacken: *"Hackers evoluem, mas devs preparados vencem!"* Vamos trancar esse cofre? üí™

> ‚ùì *Pergunta Interativa*: "Se voc√™ estivesse no time do The DAO, quais 3 mudan√ßas teria implementado para impedir o ataque?"

---